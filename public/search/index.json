[{"content":"\n背景 当需要提供一种新能力，考虑到成本问题，我们往往不会从0到1开发一个服务器，而是先在开源产品中选型对比，看是否已有能满足自身需求的开源产品(不重复造轮子的原则)。因为对开源服务器的不熟悉，部署过程中会踩这样那样的坑，效率比较低，如何快速部署并应用于实际业务场景呢？\n随便提一下，私有化部署的原因主要是考虑到数据安全，安全无小事，安全大于一切 准备工作 云主机(内部安装了docker、docker-compose、防火墙开放指定端口) 个人电脑(内部安装了docker-desktop、xshell、vscode、golang) 仔细看官方文档以及官方开源社区 注意：emqx是4.4.4版本\n部署 预期效果 (配置文件、日志)文件/目录挂载到本地磁盘\n监控、告警、可视化等功能\n协议接入、集群部署、接入安全 具体流程 个人电脑 -\u0026gt; 云主机\n单机版 -\u0026gt; 集群版(负载均衡) 启动 仔细检查docker-compose-emqx-cluster.yaml 配置文件，否则会启动失败\n启动命令： docker-compose -f docker-compose-emqx-cluster.yaml up \u0026amp; 退出命令： docker-compose -f docker-compose-emqx-cluster.yaml down 接入安全 服务端访问控制 在loaded_plugins配置文件中启用emqx_auth_mysql插件。 1 2 3 4 5 6 7 8 9 {emqx_management,true}. {emqx_dashboard,true}. {emqx_modules,false}. {emqx_recon,true}. {emqx_retainer,true}. {emqx_telemetry,true}. {emqx_rule_engine,true}. {emqx_bridge_mqtt,false}. {emqx_auth_mysql,true}. emqx默认是不设置权限，需要修改acl.conf启用鉴权。 1 2 3 {allow, {user, \u0026#34;dashboard\u0026#34;}, subscribe, [\u0026#34;$SYS/#\u0026#34;]}. {allow, {ipaddr, \u0026#34;127.0.0.1\u0026#34;}, pubsub, [\u0026#34;$SYS/#\u0026#34;, \u0026#34;#\u0026#34;]}. {deny, all, subscribe, [\u0026#34;$SYS/#\u0026#34;, {eq, \u0026#34;#\u0026#34;}]}. 修改emqx_auth_mysql.conf配置文件：修改数据库实例，创建认证表和授权表。\n用户名/密码认证防止非法客户端连接。 1 2 3 4 5 6 7 8 9 10 CREATE TABLE `mqtt_user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `password` varchar(100) DEFAULT NULL, `salt` varchar(35) DEFAULT NULL, `is_superuser` tinyint(1) DEFAULT \u0026#39;0\u0026#39;, `created` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `mqtt_username` (`username`) ) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 对 MQTT 客户端的发布和订阅操作进行权限控制。控制哪些客户端可以发布或者订阅哪些MQTT主题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TABLE `mqtt_acl` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `allow` int(1) DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;0: deny, 1: allow\u0026#39;, `ipaddr` varchar(60) DEFAULT NULL COMMENT \u0026#39;IpAddress\u0026#39;, `username` varchar(100) DEFAULT NULL COMMENT \u0026#39;Username\u0026#39;, `clientid` varchar(100) DEFAULT NULL COMMENT \u0026#39;ClientId\u0026#39;, `access` int(2) NOT NULL COMMENT \u0026#39;1: subscribe, 2: publish, 3: pubsub\u0026#39;, `topic` varchar(100) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;Topic Filter\u0026#39;, PRIMARY KEY (`id`), KEY `ipaddr` (`ipaddr`), KEY `username` (`username`), KEY `clientid` (`clientid`) ) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 客户端SDK安全 SDK引入了第三方库， 要走中台统一的三方库报备、审查，看看有没有漏洞或其他风险 。 集群部署 实际业务场景可能对高性能、高可用有着一定要求。这里以伪分布式集群为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 version: \u0026#39;3.9\u0026#39; x-default-emqx: \u0026amp;default-emqx image: emqx/emqx:4.4.4 env_file: - conf.cluster.env healthcheck: test: [\u0026#34;CMD\u0026#34;, \u0026#34;/opt/emqx/bin/emqx_ctl\u0026#34;, \u0026#34;status\u0026#34;] interval: 5s timeout: 25s retries: 5 services: haproxy: container_name: haproxy image: haproxy:2.4 privileged: true depends_on: - emqx1 - emqx2 volumes: - ./haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg - ./certs_ha/certs:/usr/local/etc/haproxy/certs ports: - \u0026#34;18083:18083\u0026#34; - \u0026#34;1883:1883\u0026#34; # - \u0026#34;8883:8883\u0026#34; - \u0026#34;8083:8083\u0026#34; # - \u0026#34;8084:8084\u0026#34; - \u0026#34;9090:9090\u0026#34; - \u0026#34;8081:8081\u0026#34; networks: - emqx_bridge working_dir: /usr/local/etc/haproxy command: - bash - -c - | set -x cat /usr/local/etc/haproxy/certs/cert.pem /usr/local/etc/haproxy/certs/key.pem \u0026gt; /tmp/emqx.pem haproxy -f /usr/local/etc/haproxy/haproxy.cfg emqx1: \u0026lt;\u0026lt;: *default-emqx container_name: node1.emqx.io environment: - \u0026#34;EMQX_HOST=node1.emqx.io\u0026#34; ports: - \u0026#34;18081:18083\u0026#34; - \u0026#34;8881:8083\u0026#34; - \u0026#34;1882:1883\u0026#34; - \u0026#34;18087:8081\u0026#34; networks: emqx_bridge: aliases: - node1.emqx.io volumes: - ./dockeremqx/emqx.conf:/opt/emqx/etc/emqx.conf - ./dockeremqx/acl.conf:/opt/emqx/etc/acl.conf - ./dockeremqx/emqx_auth_mysql.conf:/opt/emqx/etc/plugins/emqx_auth_mysql.conf - ./dockeremqx/loaded_plugins:/opt/emqx/data/loaded_plugins - ./dockeremqx/emqx1_log/log:/opt/emqx/log emqx2: \u0026lt;\u0026lt;: *default-emqx container_name: node2.emqx.io environment: - \u0026#34;EMQX_HOST=node2.emqx.io\u0026#34; ports: - \u0026#34;18082:18083\u0026#34; - \u0026#34;8882:8083\u0026#34; - \u0026#34;1881:1883\u0026#34; - \u0026#34;18088:8081\u0026#34; networks: emqx_bridge: aliases: - node2.emqx.io volumes: - ./dockeremqx/emqx.conf:/opt/emqx/etc/emqx.conf - ./dockeremqx/acl.conf:/opt/emqx/etc/acl.conf - ./dockeremqx/emqx_auth_mysql.conf:/opt/emqx/etc/plugins/emqx_auth_mysql.conf - ./dockeremqx/loaded_plugins:/opt/emqx/data/loaded_plugins - ./dockeremqx/emqx2_log/log:/opt/emqx/log networks: emqx_bridge: driver: bridge name: emqx_bridge # ipam: # driver: default # config: # - subnet: 172.100.239.0/24 # gateway: 172.100.239.1 协议接入 应用层协议包括mqtt、websocket、http。负载均衡器方面的配置非常关键，下面以haproxy为例(核心配置)：\n粘性会话是在haproxy中配置的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 defaults log global mode http option httplog # Replace 1024000 with deployment connections maxconn 50000 timeout connect 30000 timeout client 600s timeout server 600s timeout tunnel 1h timeout client-fin 30s timeout http-keep-alive 5s timeout http-request 5s frontend emqx_tcp mode tcp option tcplog bind *:1883 # Reject connections that have an invalid MQTT packet # tcp-request content reject unless { req.payload(0,0), mqtt_is_valid } default_backend emqx_tcp_back frontend emqx_ws mode tcp option httplog bind *:8083 acl host_ws hdr_beg(Host) -i ws. acl hdr_connection_upgrade hdr(Connection) -i upgrade acl hdr_upgrade_websocket hdr(Upgrade) -i websocket use_backend emqx_ws_back if hdr_connection_upgrade hdr_upgrade_websocket default_backend emqx_ws_back backend emqx_tcp_back mode tcp stick on req.payload(0,0),mqtt_field_value(connect,client_identifier) server emqx-1 node1.emqx.io:1883 check-send-proxy send-proxy-v2 server emqx-2 node2.emqx.io:1883 check-send-proxy send-proxy-v2 backend emqx_ws_back mode http balance roundrobin acl hdr_connection_upgrade hdr(Connection) -i upgrade acl hdr_upgrade_websocket hdr(Upgrade) -i websocket acl hdr_websocket_key hdr_cnt(Sec-WebSocket-Key) eq 1 acl hdr_websocket_version hdr_cnt(Sec-WebSocket-Version) eq 1 server emqx-1 node1.emqx.io:8083 server emqx-2 node2.emqx.io:8083 测试 功能测试 目标：连接、发布、订阅等功能符合预期。\nEMQX是否正在运行的判断方法：正常进入管理后台界面、正常监听某些指定端口。\n运行指定语言的客户端SDK来进行关键功能测试，比如golang版本的SDK paho.golang ，JS版本的SDK mqtt-client-WebSocket 。当然也可以通过官方推荐的可视化工具来测试。 测试方法 测试点 期望结果 具体说明 客户端断线重连 emqx重启后，客户端自动重连 取决于客户端SDK是否实现了心跳重连 消息下发成功率 正常情况下，QoS 1报文不会丢失消息 Broker提供3种QoS，通常选择QoS 1报文(至少送达一次)来兼顾吞吐量和发布质量。 消息状态码 每次操作都能拿到实时且正确的状态码 状态码是MQTT 5.0新特性，客户端SDK需要支持5.0协议 性能测试 目标：确认是否与官方宣称的性能接近(机器硬件条件相同情况下)，提前暴露可能存在的BUG 测试方法 一般官方都会提供配套的压测工具脚本，比如emqtt-bench开源项目，将其运行在云主机，压测效果最好，减少网络传输时延。 1 ./emqtt_bench sub -t bench -h ${ip} -p 1883 -c 1000 -i 10 -q 1 -u ${username}-P ${password} 压测注意事项 压测客户端被限制：ulimit命令修改进程最大连接数限制，否则会压测不准，最大并发连接数卡在1007上不去。\n发布端发送消息速率过快： max_mqueue_len参数默认为1000，队列满会消息发送失败 负载均衡器maxconn设置过小：haproxy的maxconn默认值是1000，需要调大为50000\n总结 搭建开源服务器，需要实现协议接入、集群部署、接入安全等核心功能来满足业务需求，最终目的是为业务带来一定的价值。\n","date":"2022-10-30T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img1.png","permalink":"https://soli.seekincs.com/2022/10/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E5%BC%80%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"如何快速部署开源服务器"},{"content":"Questions Q1: TCP服务最大并发连接数？ 即有一个 TCP 服务程序的地址是 1.2.3.4:8765，问它从理论上能接受多少个并发连接？\n单独谈论“TCP 并发连接数”是没有意义的，因为连接数基本上是要多少有多少。更有意义的性能指标或许是：“每秒收发多少条消息”、“每秒收发多少字节的数据”、“支持多少个活动的并发客户”等等。\n在只考虑 IPv4 的情况下，并发数的理论上限是 2^48。考虑某些 IP 段被保留了，这个上界可适当缩小，但数量级不变。实际的限制是操作系统全局文件描述符的数量，以及内存大小。\n2^48由来： 一个 TCP 连接有两个 end points，每个 end point 是 {ip, port}，题目说其中一 个 end point 已经固定，那么留下一个 end point 的自由度，即 2^48。客户端 IP 的上限是 2^32 个，每个客户端 IP 发起连接的上限是 2^16，乘到一起得到理论上限\n在真实的 Linux 系统中，可以通过调整内核参数来支持上百万并发连接。\nQ2: TCP 的可靠性有多高? Realize That TCP Is a Reliable Protocol, Not an Infallible Protocol。\n那么 TCP 在哪种情况下会出错？这里说的“出错”指的是收到的数据与发送的数据不一致，而不是数据不可达。\n什么情况下 TCP 传送的数据会出错？\nIP header 和 TCP header 的 checksum 是一种非常弱的 16-bit check sum 算法， 其把数据当成反码表示的 16-bit integers，再加到一起。这种 checksum 算法能检出 一些简单的错误，而对某些错误无能为力。\n路由器可能出现硬件故障，比方说它的内存故障（或偶然错误）导致收发 IP 报 文出现多 bit 的反转或双字节交换，这个反转如果发生在 payload 区，那么无法用 链路层、网络层、传输层的 check sum 查出来，只能通过应用层的 check sum 来检 测。\n另外一个例证：下载大文件的时候一般都会附上 MD5，这除了有安全方面的考 虑（防止篡改），也说明应用层应该自己设法校验数据的正确性。这是 end-to-end principle 的一个例证。\nQ4: TCP如何实现可靠？ TCP 作为一个可靠的传输层协议，其核心有三点：\nPositive acknowledgement with retransmission； Flow control using sliding window （包括 Nagle 算法等）； Congestion control （包括 slow start、congestion avoidance、fast retransmit 等）。 第一点已经足以满足“可靠性”要求（为什么？）；第二点是为了提高吞吐量，充 分利用链路层带宽；第三点是防止过载造成丢包。换言之，第二点是避免发得太慢， 第三点是避免发得太快，二者相互制约。从反馈控制的角度看，TCP 像是一个自适应 的节流阀，根据管道的拥堵情况自动调整阀门的流量。 Q3: C10K问题？ what：所谓C10K问题，就是Client 10000 Problem，即“在同时连接到服务器的客户端数量超过10000个的环境中，即便硬件性能足够，依然无法正常提供服务”这样一个问题\nwhat: 所谓最弱连接问题，就是如果往两端用力拉一条由很多环（连接）组成的锁链，其中最脆弱的一个连接会先断掉。因此，锁链整体的强度取决于其中最脆弱的一环。安全问题也是一样，整体的强度取决于其中最脆弱的部分。\nQ6: 常见的并发网络服务程序设计方案 ","date":"2022-12-03T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img1.png","permalink":"https://soli.seekincs.com/2022/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E4%BD%BF%E7%94%A8muduo-c-%E7%BD%91%E7%BB%9C%E5%BA%93.pdf/","title":"Linux多线程服务端编程：使用muduo C++网络库.pdf"},{"content":"栽在了简单数学题上 Codeforces Round #836 (Div. 2) B题目链接\n反思：\n其实就是((n-1)*(n+1)+1)/n=n。。。对简单数学不够敏感哎\n题目意思没理解对，误以为𝑎1+𝑎2+⋯+𝑎𝑛求和可以不整除𝑛。。。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int t, n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if (n \u0026amp; 1) { for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;%d\u0026#34;,n); if(i!=n){ printf(\u0026#34; \u0026#34;); } } printf(\u0026#34;\\n\u0026#34;); continue; } else { printf(\u0026#34;1\u0026#34;); for (int i = 1; i \u0026lt;= n-1; i++) { printf(\u0026#34; %d\u0026#34;,n+1); } printf(\u0026#34;\\n\u0026#34;); } } return 0; } ","date":"2022-11-25T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img7.png","permalink":"https://soli.seekincs.com/2022/11/codeforces-practices/","title":"codeforces practices"},{"content":"Questions Q1:master与worker进程通信方式？ 即master进程如何通知worker进程停止服务或更换日志文件呢？ 对于这样控制进程运行的进程间通信方式，Nginx采用的是信号。见ngx_signal_handler方法。\n在ngx_worker_process_cycle方法中，通过检查ngx_exiting、ngx_terminate、ngx_quit、 ngx_reopen这4个标志位来决定后续动作。\nQ2:worker进程的惊群问题？ 即如何解决多个worker子进程监听同一端口引起的“惊群”现象的?\n加锁：ngx_process_events_and_timers方法中调用了ngx_trylock_accept_mutex方法。\nnginx规定了同一时刻只能有唯一一个worker子进程监听Web端口，这样就不会发生“惊 群”了，此时新连接事件只能唤醒唯一正在监听端口的worker子进程。\nQ3:worker进程的均衡问题？ 即如何均衡多个worker子进程上处理的连接数?\n与“惊群”问题的解决方法一样，只有打开了accept_mutex锁，才能实现worker子进程间的 负载均衡。\nQ4:master进程主要功能？ master进程不需要处理网络事件，它不负责业务的执行，只会通过管理worker等子进程 来实现重启服务、平滑升级、更换日志文件、配置文件实时生效等功能。\n问题探索 nginx特点 选择Nginx的核心理由还是它能在支持高并发请求的同时保持高效的服务。\n低内存消耗 高可靠性:一个master管理进程、多个worker工作进程的设计方式 高扩展性:高度模块化的设计 更快 事件处理 开发一个简单的HTTP模块 todo: 开发ngx_http_mytest_module\n参考例子\n其他 vscode本地调试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;debug nginx\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/objs/nginx\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false } ] } mkcert创建自签名SSL证书 1 2 3 mkcert -install # 将 mkcert 的认证机构安装到服务器上 mkcert -CAROOT # 查看 CA 证书的位置，在PC上安装 rootCA.crt 证书 mkcert www.aaa.com aiPlatform.dev localhost 127.0.0.1 ::1 43.139.87.74 # 生成证书，配置在nginx.conf中 nginx四层转发 源码编译时，执行以下命令手动加载stream模块:\n./auto/configure \u0026ndash;with-http_ssl_module \u0026ndash;prefix=/home/github/nginx \u0026ndash;with-stream\n然后在nginx.conf添加以下配置内容支持tcp转发，stream_backend程序: 1 2 3 4 5 6 7 8 9 10 11 12 stream { upstream stream_backend { zone tcp_servers 64k; hash $remote_addr; server 127.0.0.1:18000; } server { listen 8000; proxy_pass stream_backend; } } ","date":"2022-11-22T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img1.png","permalink":"https://soli.seekincs.com/2022/11/nginx%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/","title":"nginx工作笔记"},{"content":"centos版本 目前都是用centos7\ncat /etc/redhat-release alias 解决重启后alias失效问题。尽量放在home目录下\nvim ~/.bashrc alias cdhub='cd /home/github' alias cdclash='cd /home/clash' source ~/.bashrc 查看项目代码行数 yum -y install cloc cloc src 显示当前文件夹大小 du -hs 安装git2.x sudo yum install https://packages.endpointdev.com/rhel/7/os/x86_64/endpoint-repo.x86_64.rpm sudo yum install git git --version git config --global user.name \u0026quot;Your Name\u0026quot; git config --global user.email \u0026quot;email@example.com\u0026quot; ssh-keygen -t rsa -C \u0026quot;your_email@youremail.com\u0026quot; cat /root/.ssh/id_rsa.pub gcc升级到7.13 sudo yum install centos-release-scl sudo yum install devtoolset-7-gcc* ln -sf /opt/rh/devtoolset-7/root/usr/bin/gcc /usr/bin/gcc ln -sf /opt/rh/devtoolset-7/root/usr/bin/g++ /usr/bin/g++ 安装cmake3 yum -y install cmake3 sudo ln -s /usr/bin/cmake3 /usr/bin/cmake cmake --version 安装指定版本\nwget https://github.com/Kitware/CMake/releases/download/v3.24.0/cmake-3.24.0-linux-x86_64.tar.gz tar -zxvf cmake-3.24.0-linux-x86_64.tar.gz ln -sf /usr/local/cmake-3.24.0-linux-x86_64/bin/cmake /usr/bin/cmake linux开启swap分区 dd if=/dev/zero of=/swapfile bs=64M count=64 chmod 0600 /swapfile mkswap /swapfile swapon /swapfile swapon -s https://www.cnblogs.com/Axianba/p/13131620.html\n安装mysql-8.0.24 cmake命令\nmkdir build \u0026amp;\u0026amp; cd build cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DCMAKE_C_COMPILER=/usr/bin/gcc -DCMAKE_CXX_COMPILER=/usr/bin/g++ -DSYSCONFDIR=/etc -DWITH_BOOST=/usr/local/boost -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DENABLED_LOCAL_INFILE=ON -DWITH_INNODB_MEMCACHED=ON -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_FEDERATED_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITHOUT_EXAMPLE_STORAGE_ENGINE=1 -DWITH_PERFSCHEMA_STORAGE_ENGINE=1 -DFORCE_INSOURCE_BUILD=1 -DMYSQL_TCP_PORT=3306 编译，安装，初始化，启动：\ngroupadd mysql useradd -r -g mysql -s /bin/false mysql make\u0026amp;\u0026amp;make install chown -R mysql:mysql /usr/local/mysql/ /usr/local/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data /usr/local/mysql/bin/mysqld_safe --defaults-file=/usr/local/mysql/etc/my.cnf 统计80端口连接数 netstat -nat | grep -i \u0026quot;80\u0026quot; | wc -l netstat -nat | grep -i \u0026quot;18000\u0026quot; | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' # 查看TCP连接状态 生成32位随机串 cat /dev/urandom | head -n 10 | md5sum 磁盘占满排查 df -hl du -s /* | sort -nr |head # 选出排在前面的10个，head改成tail则是后面10个 du -sh /* | sort -nr # 加了h排序错乱 du -sh /home/* | sort -nr 内存占用高排查 top -o %MEM # 按内存占用排序 vmstat 2 # 每隔2秒展示内存占用情况 kill -9 `ps -ef| grep tail |awk '{print $2}' ` cat /proc/24573/status # 查看进程内存 健康检查脚本health-check-script 健康检查脚本\n具体使用例子\ncentos7安装clash url1\nurl2\n安装prometheus和grafana 场景: 编写Dockerfile\ngrafana8.0.6官网下载\nFROM quay.io/prometheus/prometheus USER root RUN echo 'Asia/Shanghai' \u0026gt;/etc/timezone ADD prometheus.yml /etc/prometheus/ 解压 tar -zxvf grafana-8.0.6.linux-amd64.tar.gz 服务启动脚本 #!/bin/sh mainpid=$(lsof -i:8686|grep 'LISTEN'|awk '{print $2}') echo $mainpid if [ $mainpid \u0026gt; 0 ];then echo \u0026quot;main process id:$mainpid\u0026quot; kill -9 $mainpid if [ $? -eq 0 ];then echo \u0026quot;kill $mainpid success\u0026quot; go run main.go else echo \u0026quot;kill $mainpid fail\u0026quot; fi else go run main.go fi ","date":"2022-11-14T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img7.png","permalink":"https://soli.seekincs.com/2022/11/centos7%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/","title":"Centos7工作笔记"},{"content":"问题探索 调度器 调度器的工作是在适当的时机将合适的协程分配到合适的位置，在调度过程中需要保证公平和效率。\n调度时机 根据调度方式的不同，将调度时机分为主动、被动和抢占调度。\n主动调度 需要先从当前协程切换到协程g0，取消G与M之间的绑定关系，将G放入全局运行队列，并调用schedule函数开始新一轮的循环。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func goschedImpl(gp *g) { status := readgstatus(gp) if status\u0026amp;^_Gscan != _Grunning { dumpgstatus(gp) throw(\u0026#34;bad g status\u0026#34;) } casgstatus(gp, _Grunning, _Grunnable) // 取消G与M之间的绑定关系 dropg() lock(\u0026amp;sched.lock) // 把G放入全局运行队列 globrunqput(gp) unlock(\u0026amp;sched.lock) // 进入新一轮调度 schedule() } 被动调度 和主动调度类似的是，被动调度需要先从当前协程切换到协程g0，更新协程的状态并解绑与M的关系，重新调度。 和主动调度不同的是，被动调度不会将G放入全局运行队列，因为当前G的状态不是_Grunnable而是_Gwaiting， 所以，被动调度需要一个额外的唤醒机制。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func park_m(gp *g) { _g_ := getg() casgstatus(gp, _Grunning, _Gwaiting) dropg() if fn := _g_.m.waitunlockf; fn != nil { ok := fn(gp, _g_.m.waitlock) _g_.m.waitunlockf = nil _g_.m.waitlock = nil if !ok { if trace.enabled { traceGoUnpark(gp, 2) } casgstatus(gp, _Gwaiting, _Grunnable) execute(gp, true) // Schedule it back, never returns. } } schedule() } 抢占调度 为了让每个协程都有执行的机会，并且最大化利用CPU资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // proc.retake函数 func retake(now int64) uint32 { n := 0 lock(\u0026amp;allpLock) // 遍历所有的P for i := 0; i \u0026lt; len(allp); i++ { _p_ := allp[i] if _p_ == nil { continue } pd := \u0026amp;_p_.sysmontick s := _p_.status sysretake := false if s == _Prunning || s == _Psyscall { // 如果G运行时间过长则抢占 t := int64(_p_.schedtick) if int64(pd.schedtick) != t { pd.schedtick = uint32(t) pd.schedwhen = now } else if pd.schedwhen+forcePreemptNS \u0026lt;= now { // 连续运行超过10ms，设置抢占请求 preemptone(_p_) sysretake = true } } // P处于系统调用之中，检查是否需要抢占 if s == _Psyscall { // 如果已经超过了一个系统监控的tick(20us)，则从系统调用中抢占P // ...省略 } } unlock(\u0026amp;allpLock) return uint32(n) } 调度策略 调度协程的优先级与顺序如下所示:\ngraph LR A[runnext] --\u003e B{nil?}; B -- Yes --\u003e C[p.runq]; C --\u003e D{head=tail?}; D -- Yes ----\u003e F[schet.runq]; F --\u003e G{runqsize=0?}; G -- Yes --\u003e H[从其他P窃取]; H --\u003e J{find?}; J -- Yes ----\u003e K[找到G]; J -- No ----\u003e L[未找到G,休眠]; F -- No ----\u003e I[找到G]; D -- No --\u003e E[找到G]; B -- No ----\u003e W[找到G]; 其他 编译 编译脚本(all.bash/make.bash)中注释掉，跳过编译test，因为太慢\nmkdir -p ~/mygo/bin cd ~/mygo/bin ln -sf /usr/local/projs/go/bin/go mygo mygo version mygo run helloworld.go ","date":"2022-11-14T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img6.png","permalink":"https://soli.seekincs.com/2022/11/go-source-code-learning/","title":"go source code learning"},{"content":"wireshark捕获grpc消息 具体参考 ","date":"2022-11-14T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img5.png","permalink":"https://soli.seekincs.com/2022/11/grpcgo-source-code-learning/","title":"grpcgo source code learning"},{"content":"k8s集群部署mqtt需要解决的问题 跨vpc搭建k8s集群 集成sidecar todo\n","date":"2022-11-14T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img4.png","permalink":"https://soli.seekincs.com/2022/11/k8s-cluster-in-action/","title":"k8s cluster in Action"},{"content":"指南 建议一： 从handler出发 MySQL插件式引擎，连接MySQL Server与各种存储引擎的，是其Handler 模块 —— hanlder模块是灵魂； 以InnoDB引擎为例，从ha_innodb.cc文件出发，理解其中的每一个接口的 功能，能够上达MySQL Server，下抵InnoDB引擎的内部实现； 建议二： 不放过源码中的每一处注释 MySQL/InnoDB源码中，有很多注释，一些注释相当详细，对理解某一个 函数/某一个功能模块都相当有用； 问题探索 一条SQL的生命周期 参考文章\nmysql插件化架构 mysql8.0取消查询缓存 官方说明\n网络IO模型 参考文章\n其他 mysql8.0.24源码编译安装 主要是参考这篇文章，操作过程中根据报错进行fix，特别是修改my.cnf配置文件。\n编译安装问题 OpenSSL 版本不兼容\n不兼容1.1版本，需要openssl1.0.2，通过yum install openssl-devel。\n磁盘空间不足\n60g磁盘满了，导致make 终止，/data目录删掉即可。\nfatal error: error writing to /tmp/ccFtecZv.s: No space left on device 内存不足\n需要开启swap分区 g++: internal compiler error: Killed (program cc1plus) 太吃内存，make巨慢\n没找到解决方案\u0026hellip; 缺少依赖组件\n可能是缺少ncurses-devel yum install ncurses-devel libaio bison zlib-devel openssl openssl-devel patch mysqld启动问题 磁盘空间不足 注意my.cnf配置文件，特别innodb参数配置，可能因系统内存或磁盘容量导致启动失败\n查看系统磁盘: df -h\n[InnoDB] Error number 28 means \u0026lsquo;No space left on device\u0026rsquo;\nvscode本地调试mysql8.0.24 先在云服务器上执行以下命令：\n./mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data launch.json配置文件如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;debug mysql\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;/usr/local/mysql/bin/mysqld\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;--defaults-file=/usr/local/mysql/etc/my.cnf\u0026#34;], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false } ] } 源码结构 安装tree工具，执行tree -d -L 1命令：\n|-- build |-- client |-- cmake |-- components |-- Docs |-- doxygen_resources |-- extra |-- include |-- libbinlogevents |-- libbinlogstandalone |-- libmysql |-- libservices |-- man |-- mysql-test |-- mysys |-- packaging |-- plugin |-- router |-- scripts |-- share |-- source_downloads |-- sql |-- sql-common |-- storage |-- strings |-- support-files |-- testclients |-- unittest |-- utilities `-- vio 语雀代码画时序图： https://www.bookstack.cn/read/yuque/34.md\nMysql线程的基本设置 mysql\u0026gt; show variables like 'thread%'; +-------------------+---------------------------+ | Variable_name | Value | +-------------------+---------------------------+ | thread_cache_size | 1536 | | thread_handling | one-thread-per-connection | | thread_stack | 524288 | +-------------------+---------------------------+ 3 rows in set (0.05 sec) mysql\u0026gt; show global status like 'Thread%'; +-------------------+-------+ | Variable_name | Value | +-------------------+-------+ | Threads_cached | 0 | | Threads_connected | 1 | | Threads_created | 1 | | Threads_running | 1 | +-------------------+-------+ 4 rows in set (0.07 sec) 远程连接 root忘记密码\n--- mysqld模块下增加skip-grant-tables配置,免密登录后执行以下命令： update user set authentication_string = '' where user ='root'; --- 注释掉skip-grant-tables配置,重新登录，设置新密码： ALTER USER 'root'@'localhost' IDENTIFIED BY 'root123456'; 允许外部访问\nuse mysql; update user set host='%' where user ='root'; FLUSH PRIVILEGES; 测试mermaid sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! ","date":"2022-11-14T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img2.png","permalink":"https://soli.seekincs.com/2022/11/mysql-source-code-learning/","title":"mysql source code learning"},{"content":"问题探索 事件处理 其他 vscode本地调试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;debug redis\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/src/redis-server\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;redis.conf\u0026#34;], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false } ] } redis-benchmark压测 1 2 3 4 5 cd /usr/local/projs/redis/src \u0026amp;\u0026amp; ./redis-benchmark -h ./redis-benchmark -t set -n 1000000 -r 100000000 47496.91 requests per second ./redis-benchmark -t set -n 1000000 -r 100000000 -P 16 291290.41 requests per second 查看RDB快照文件 rdb -c memory dump.rdb \u0026gt; dump_rdb.csv\n其中：size_in_bytes 内存的大小，由此可以查询内存最高的key\nredis5.0搭建伪分布式集群 具体配置参考commit\n/home/github/redis/src/redis-cli --cluster create --cluster-replicas 1 10.0.12.2:7001 10.0.12.2:7002 10.0.12.2:7003 10.0.12.2:7004 10.0.12.2:7005 10.0.12.2:7006 ./src/redis-cli -h 10.0.12.2 -p 7001 -c cluser nodes cluser info 参考资料 Redis中文网 ","date":"2022-11-14T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img1.png","permalink":"https://soli.seekincs.com/2022/11/redis-source-code-learning/","title":"redis source code learning"},{"content":"EMQX安装部署 EMQX 是一款大规模可弹性伸缩的云原生分布式物联网 MQTT 消息服务器😂。\nDocker单节点多实例 基于docker-compose+haproxy搭建伪分布式集群：\n启动：docker-compose -f docker-compose-emqx-cluster.yaml up\n关闭：docker-compose -f docker-compose-emqx-cluster.yaml down\nDocker多节点 修改emqx.conf配置文件(这里选择static方式)，集群节点开放某些端口：\ncluster.discovery = static cluster.static.seeds = emqx@120.92.94.79,emqx@120.92.88.242 rpc.port_discovery = manual rpc.tcp_server_port = 5369 两个集群节点分别执行以下命令：\ndocker run -d --name emqx_cluster -v /emqx.conf:/opt/emqx/etc/emqx.conf -v /emqx_auth_mysql.conf:/opt/emqx/etc/plugins/emqx_auth_mysql.conf -v /loaded_plugins:/opt/emqx/data/loaded_plugins --env EMQX_LOG__TO=both --env EMQX_HOST=120.92.94.79 -p 1883:1883 -p 8081:8081 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 -p 4370:4370 -p 5370:5370 -p 4369:4369 -p 5369:5369 -p 6369:6369 -p 6370:6370 emqx/emqx:4.4.4 k8s集群 见另外一篇文章，传送门\n安全 安全主要包括服务端访问控制和客户端SDK安全，具体如下：\n服务端启用emqx_auth_mysql插件实现认证和授权。\n客户端SDK引入的第三方库， 要走中台统一的三方库报备、审查，看看有没有漏洞或其他风险。\n客户端SDK 一些SDK不支持mqtt5.0，其影响是pub/sub操作无法拿到原因码。一些SDK不支持断线重连。\n注意点：client_id尽量不填(或者重连时采用第一次连接后返回的client_id)，避免client_id重复导致会话互踢。\nGo版本建议选择paho.golang，因为支持5.0协议。\nC++版本建议选择paho.mqtt.cpp，也可以参考我写的一个基于vcpkg+cmake的demo\nJS版本建议选择ws-mqtt\n压力验证 压测工具\n硬件配置：一台腾讯云服务器2c4g。\n一个master节点的k8s上运行emqx 6个pod，目前只能支持27322个订阅端，服务器CPU 100%。\n遇到的问题 client(4): EXIT for {shutdown,eaddrinuse}\n解决方法：\n扩大端口数量\n提高端口使用率\n","date":"2022-11-13T00:00:00Z","image":"https://someblogs.oss-cn-shenzhen.aliyuncs.com/thumb/img1.png","permalink":"https://soli.seekincs.com/2022/11/mqtt-broker-in-action/","title":"MQTT Broker in Action"}]